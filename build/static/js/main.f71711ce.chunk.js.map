{"version":3,"sources":["useModel.js","object-detection-video/useWebcam.js","object-detection-video/retina-canvas.js","object-detection-video/render-predictions.js","object-detection-video/ObjectDetectionVideo.js","index.js"],"names":["useModel","modelPath","useState","model","setModel","useEffect","models","load","then","useWebcam","videoRef","onLoaded","navigator","mediaDevices","getUserMedia","audio","video","facingMode","width","ideal","height","stream","current","srcObject","onloadedmetadata","getRetinaContext","canvas","ctx","getContext","scale","window","devicePixelRatio","setWidth","w","style","setHeight","h","clearAll","clearRect","x","y","setFont","font","size","parseInt","retinaFont","replace","setTextBaseLine","textBaseline","setStrokeStyle","strokeStyle","setLineWidth","lineWidth","strokeRect","setFillStyle","fillStyle","measureText","text","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fillRect","fillText","getLabelText","prediction","scoreText","score","toFixed","label","renderPredictions","predictions","textHeight","forEach","bbox","predictionText","console","log","includes","Math","round","textWidth","border","xPadding","yPadding","ObjectDetectionVideo","React","memo","onPrediction","fit","mirrored","render","useRef","canvasRef","detectFrame","useCallback","a","detect","wantedWidth","offsetWidth","wantedHeight","offsetHeight","videoWidth","videoHeight","scaleX","scaleY","min","max","xOffset","yOffset","offsetPredictions","map","requestAnimationFrame","position","left","top","objectFit","transform","autoPlay","playsInline","muted","ref","App","className","rootElement","document","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.f71711ce.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\n\nimport models from '@cloud-annotations/models'\n\nconst useModel = (modelPath) => {\n  const [model, setModel] = useState()\n  useEffect(() => {\n    models.load(modelPath).then((model) => {\n      setModel(model)\n    })\n  }, [modelPath])\n  return model\n}\n\nexport default useModel\n","import { useEffect } from 'react'\n\nconst useWebcam = (videoRef, onLoaded) => {\n  useEffect(() => {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: 'user',\n            width: { ideal: 4096 },\n            height: { ideal: 2160 },\n          },\n        })\n        .then((stream) => {\n          videoRef.current.srcObject = stream\n          videoRef.current.onloadedmetadata = () => {\n            onLoaded()\n          }\n        })\n    }\n  }, [onLoaded, videoRef])\n}\n\nexport default useWebcam\n","export const getRetinaContext = (canvas) => {\n  const ctx = canvas.getContext('2d')\n  const scale = window.devicePixelRatio\n  let width = canvas.width / scale\n  let height = canvas.height / scale\n  return {\n    setWidth: (w) => {\n      width = w\n      canvas.style.width = w + 'px'\n      canvas.width = w * scale\n    },\n    setHeight: (h) => {\n      height = h\n      canvas.style.height = h + 'px'\n      canvas.height = h * scale\n    },\n    width: width,\n    height: height,\n    clearAll: () => {\n      return ctx.clearRect(0, 0, width * scale, height * scale)\n    },\n    clearRect: (x, y, width, height) => {\n      return ctx.clearRect(x * scale, y * scale, width * scale, height * scale)\n    },\n    setFont: (font) => {\n      const size = parseInt(font, 10) * scale\n      const retinaFont = font.replace(/^\\d+px/, size + 'px')\n      ctx.font = retinaFont\n    },\n    setTextBaseLine: (textBaseline) => {\n      ctx.textBaseline = textBaseline\n    },\n    setStrokeStyle: (strokeStyle) => {\n      ctx.strokeStyle = strokeStyle\n    },\n    setLineWidth: (lineWidth) => {\n      ctx.lineWidth = lineWidth * scale\n    },\n    strokeRect: (x, y, width, height) => {\n      return ctx.strokeRect(x * scale, y * scale, width * scale, height * scale)\n    },\n    setFillStyle: (fillStyle) => {\n      ctx.fillStyle = fillStyle\n    },\n    measureText: (text) => {\n      const metrics = ctx.measureText(text)\n      return {\n        width: metrics.width / scale,\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft / scale,\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight / scale,\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent / scale,\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent / scale,\n      }\n    },\n    fillRect: (x, y, width, height) => {\n      return ctx.fillRect(x * scale, y * scale, width * scale, height * scale)\n    },\n    fillText: (text, x, y) => {\n      return ctx.fillText(text, x * scale, y * scale)\n    },\n  }\n}\n","const getLabelText = (prediction) => {\n  const scoreText = (prediction.score * 100).toFixed(1)\n  return `${prediction.label} ${scoreText}%`\n}\n\nexport const renderPredictions = (ctx, predictions) => {\n  // Font options.\n  const font = `${16}px 'ibm-plex-sans', Helvetica Neue, Arial, sans-serif`\n  ctx.setFont(font)\n  ctx.setTextBaseLine('top')\n  const border = 4\n  const xPadding = 16\n  const yPadding = 8\n  const offset = 6\n  const textHeight = parseInt(font, 10) // base 10\n\n  predictions.forEach((prediction) => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    const width = prediction.bbox[2]\n    const height = prediction.bbox[3]\n\n    const predictionText = getLabelText(prediction)\n    console.log(predictionText)\n    console.log(predictionText.includes(\"No\"))\n    if (predictionText.includes(\"No\")){\n    // Draw the bounding box.\n    //console.log(predictionText)\n    ctx.setStrokeStyle('#FF0000')\n    ctx.setLineWidth(border)\n    }\n    else{\n      ctx.setStrokeStyle('#00FF00')\n      ctx.setLineWidth(border)\n    }\n\n    ctx.strokeRect(\n      Math.round(x),\n      Math.round(y),\n      Math.round(width),\n      Math.round(height)\n    )\n    // Draw the label background.\n    if (predictionText.includes(\"No\")){\n    ctx.setFillStyle('#FF0000')\n    }\n    else{\n      ctx.setFillStyle('#00FF00')\n    }\n    const textWidth = ctx.measureText(predictionText).width\n    ctx.fillRect(\n      Math.round(x - border / 2),\n      Math.round(y - (textHeight + yPadding) - offset),\n      Math.round(textWidth + xPadding),\n      Math.round(textHeight + yPadding)\n    )\n  })\n\n  predictions.forEach((prediction) => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n\n    const predictionText = getLabelText(prediction)\n    // Draw the text last to ensure it's on top.\n    ctx.setFillStyle('#ffffff')\n    ctx.fillText(\n      predictionText,\n      Math.round(x - border / 2 + xPadding / 2),\n      Math.round(y - (textHeight + yPadding) - offset + yPadding / 2)\n    )\n  })\n}\n","import React, { useRef, useCallback } from 'react'\n\nimport useWebcam from './useWebcam'\nimport { getRetinaContext } from './retina-canvas'\nimport { renderPredictions } from './render-predictions'\n\nconst ObjectDetectionVideo = React.memo(\n  ({ model, onPrediction, fit, mirrored, render }) => {\n    const videoRef = useRef()\n    const canvasRef = useRef()\n\n    useWebcam(videoRef, () => {\n      detectFrame()\n    })\n\n    const detectFrame = useCallback(async () => {\n      const predictions = await model.detect(videoRef.current)\n      if (onPrediction) {\n        onPrediction(predictions)\n      }\n\n      const wantedWidth = videoRef.current.offsetWidth\n      const wantedHeight = videoRef.current.offsetHeight\n      const videoWidth = videoRef.current.videoWidth\n      const videoHeight = videoRef.current.videoHeight\n\n      const scaleX = wantedWidth / videoWidth\n      const scaleY = wantedHeight / videoHeight\n\n      let scale\n      if (fit === 'aspectFit') {\n        scale = Math.min(scaleX, scaleY)\n      } else {\n        scale = Math.max(scaleX, scaleY)\n      }\n\n      const xOffset = (wantedWidth - videoWidth * scale) / 2\n      const yOffset = (wantedHeight - videoHeight * scale) / 2\n\n      const ctx = getRetinaContext(canvasRef.current)\n\n      ctx.setWidth(wantedWidth)\n      ctx.setHeight(wantedHeight)\n      ctx.clearAll()\n\n      // Update predictions to match canvas.\n      const offsetPredictions = predictions.map((prediction) => {\n        let x = prediction.bbox[0] * scale + xOffset\n        const y = prediction.bbox[1] * scale + yOffset\n        const width = prediction.bbox[2] * scale\n        const height = prediction.bbox[3] * scale\n\n        if (mirrored) {\n          x = wantedWidth - x - width\n        }\n        return { ...prediction, bbox: [x, y, width, height] }\n      })\n\n      const renderFunction = render || renderPredictions\n\n      renderFunction(ctx, offsetPredictions)\n      requestAnimationFrame(() => {\n        detectFrame()\n      })\n    }, [fit, mirrored, model, onPrediction, render])\n\n    if (canvasRef.current) {\n      canvasRef.current.style.position = 'absolute'\n      canvasRef.current.style.left = '0'\n      canvasRef.current.style.top = '0'\n    }\n\n    if (videoRef.current) {\n      videoRef.current.style.width = '100%'\n      videoRef.current.style.height = '100%'\n      if (fit === 'aspectFit') {\n        videoRef.current.style.objectFit = 'contain'\n      } else {\n        videoRef.current.style.objectFit = 'cover'\n      }\n\n      if (mirrored) {\n        videoRef.current.style.transform = 'scaleX(-1)'\n      } else {\n        videoRef.current.style.transform = 'scaleX(1)'\n      }\n    }\n\n    return (\n      <div style={{ position: 'relative' }}>\n        <video autoPlay playsInline muted ref={videoRef} />\n        <canvas ref={canvasRef} />\n      </div>\n    )\n  }\n)\n\nexport default ObjectDetectionVideo\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport useModel from './useModel'\nimport ObjectDetectionVideo from './object-detection-video/ObjectDetectionVideo'\n\nimport './index.css'\n\nconst handlePrediction = (predictions) => {\n  console.timeEnd('detect')\n  console.time('detect')\n  console.log(predictions)\n}\n\nconst render = (ctx, predictions) => {\n  predictions.forEach((prediction) => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    const width = prediction.bbox[2]\n    const height = prediction.bbox[3]\n\n    ctx.setStrokeStyle('#0062ff')\n    ctx.setLineWidth(4)\n    ctx.strokeRect(\n      Math.round(x),\n      Math.round(y),\n      Math.round(width),\n      Math.round(height)\n    )\n  })\n}\n\nconst App = () => {\n  const model = useModel(process.env.PUBLIC_URL + '/model_web')\n\n  return (\n    <div className=\"fillPage\">\n      <ObjectDetectionVideo\n        model={model}\n        // onPrediction={handlePrediction}\n        // render={render}\n        // aspectFill: The option to scale the video to fill the size of the view.\n        //             Some portion of the video may be clipped to fill the view's\n        //             bounds.\n        // aspectFit:  The option to scale the video to fit the size of the view\n        //             by maintaining the aspect ratio. Any remaining area of the\n        //             view's bounds is transparent.\n        fit=\"aspectFill\"\n        // mirrored:   mirror the video about its vertical axis.\n        mirrored\n      />\n    </div>\n  )\n}\n\nconst rootElement = document.getElementById('root')\nReactDOM.render(<App />, rootElement)\n"],"sourceRoot":""}